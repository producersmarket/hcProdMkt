'use strict';

var className = "offerZome";

// -----------------------------------------------------------------
//  This stub Zome code file was auto-generated by hc-scaffold
// -----------------------------------------------------------------

// -----------------------------------------------------------------
//  Exposed functions with custom logic https://developer.holochain.org/API_reference
// -----------------------------------------------------------------

function offerEntryCreate (offerEntry) {
  console.log(className+".offerEntryCreate("+offerEntry+")");

  debugObject(offerEntry);

  var offerEntryHash = commit("offerEntry", offerEntry);
  console.log("offerEntryHash = "+offerEntryHash);

  var listingHash = offerEntry['listing']
  debug(listingHash)

  var offerSeller = getLinks(listingHash, "listing_source", { Load: false })
  debug(offerSeller)

  var seller = get(listingHash, { GetMask: HC.GetMask.Sources })[0]
  debug(seller)

  var me = App.Agent.Hash;
  commit("offer_links",{Links: [{Base: offerEntryHash,Link: me, Tag: "offer_source"}]});
  commit("offer_links",{Links: [{Base: offerEntryHash,Link: seller, Tag: "listing_source"}]});

  return offerEntryHash;
}

function offerEntryRead (offerEntryHash) {
  console.log(className+".offerEntryRead("+offerEntryHash+")");

  var offerEntry = get(offerEntryHash);
  debug(offerEntry)
  debugObject(offerEntry);

  var offerSeller = getLinks(offerEntryHash, "listing_source", { Load: false })[0]['Hash']
  debug("Seller: " + offerSeller)
  var offerBuyer = getLinks(offerEntryHash, "offer_source", { Load: false })[0]['Hash']
  debug("Buyer: " + offerBuyer)

  return offerEntry;
}

function offerEntryUpdate (offerEntryHash) {
  console.log(className+".offerEntryUpdate("+offerEntryHash+")");

  var sampleValue={"offer_price_cents":54321,"listing":"hash","expires_at":1531614489,"created_at":1531614489,"extraField":true};
  var offerEntryOutHash = update("offerEntry", sampleValue, offerEntryHash);
  return offerEntryOutHash;
}

function offerEntryDelete (offerEntryHash) {
  console.log(className+".offerEntryDelete("+offerEntryHash+")");

  var result = remove(offerEntryHash, "");
  return result;
}


// -----------------------------------------------------------------
//  The Genesis Function https://developer.holochain.org/genesis
// -----------------------------------------------------------------

/**
 * Called only when your source chain is generated
 * @return {boolean} success
 */
function genesis () {
  return true;
}

// -----------------------------------------------------------------
//  Validation functions for every change to the local chain or DHT
// -----------------------------------------------------------------

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryType - the type of entry
 * @param {*} entry - the entry data to be set
 * @param {object} header - header for the entry containing properties EntryLink, Time, and Type
 * @param {*} package - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateCommit (entryType, entry, header, package, sources) {
  console.log(className+".validateCommit("+entryType+", "+entry+", "+header+", "+package+", "+sources+")");
  debugHeader(header);
  switch (entryType) {
    case "offerEntry":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "offer_links":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryType - the type of entry
 * @param {*} entry - the entry data to be set
 * @param {object} header - header for the entry containing properties EntryLink, Time, and Type
 * @param {*} package - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validatePut (entryType, entry, header, package, sources) {
  console.log(className+".validatePut("+entryType+", "+entry+", "+header+", "+package+", "+sources+")");
  debugHeader(header);
  switch (entryType) {
    case "offerEntry":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryType - the type of entry
 * @param {*} entry - the entry data to be set
 * @param {object} header - header for the entry containing properties EntryLink, Time, and Type
 * @param {string} replaces - the hash for the entry being updated
 * @param {*} package - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateMod (entryType, entry, header, replaces, package, sources) {
  console.log(className+".validateMod("+entryType+", "+entry+", "+header+", "+package+", "+sources+")");
  debugHeader(header);
  switch (entryType) {
    case "offerEntry":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryType - the type of entry
 * @param {string} hash - the hash of the entry to remove
 * @param {*} package - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateDel (entryType, hash, package, sources) {
  console.log(className+".validateDel("+entryType+", "+hash+", "+package+", "+sources+")");
  switch (entryType) {
    case "offerEntry":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryType - the type of entry
 * @param {string} baseHash - the hash of the base entry being linked
 * @param {?} links - ?
 * @param {*} package - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateLink (entryType, baseHash, links, package, sources) {
  console.log(className+".validateLink("+entryType+", "+baseHash+", "+links+", "+package+", "+sources+")");
  for(var i = 0; i < links.length; i++) debugLink(links[i]);
  switch (entryType) {
    case "offerEntry":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "offer_links":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to get the data needed to validate
 * @param {string} entryType - the name of entry to validate
 * @return {*} the data required for validation
 */
function validatePutPkg (entryType) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryType - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateModPkg (entryType) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryType - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateDelPkg (entryType) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryType - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateLinkPkg (entryType) {
  return null;
}

function debugHeader(header) {
  console.log("   Header ("+header.Type+"): "+header.Time+" "+header.EntryLink);
}

/*
 * Example:
 * {
 *   "Base": "Qmb3XtdnuqCRWaWPfiMtAnGjhRDKLTrLgr2TJGFKqFoA3x",
 *   "Link": "QmSGQSdWpgcAPUrSJsz9rvNu75qc1W6AMe8sBYNasK3sbE",
 *   "Tag": "relation",
 *   "LinkAction": ""
 * }
 */
function debugLink(link) {
  console.log("    Link ("+link.Tag+"): "+link.Base+" => "+link.Link);
}

function debugObject(object) {
  for(var property in object) {
      if(object.hasOwnProperty(property)) {
        console.log("    "+property+' = '+object[property]);
      }
    }
}
